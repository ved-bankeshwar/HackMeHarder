import ast
import json
import os
import yaml
import re
import sys
import argparse

class CombinedAnalyzer(ast.NodeVisitor):
    def __init__(self, file_path, all_rules):
        self.file_path = file_path
        self.findings = []
        # Initialize all sub-analyzers
        self.xss = XSSAnalyzer(file_path, all_rules.get('xss_rules', {}))
        self.rule_based = RuleBasedScanner(
            file_path,
            all_rules.get('weak_crypto_rules', []) + all_rules.get('insecure_deserialization_rules', [])
        )
        self.path_traversal_rules = all_rules
        self.unvalidated_redirect_rules = all_rules
        self.xx_rules = all_rules

        try:
            self.findings.extend(scan_deserialization_file(self.file_path))
        except Exception as e:
            print(f"[!] DeserializationAnalyzer failed: {e}")


    def visit(self, node):
        for analyzer in [self.xss, self.rule_based]:
            analyzer.visit(node)  # visit node only once

    # Only call functional analyzers that need the full file/tree
        self.findings.extend(scan_deserialization_file(self.file_path))
        self.findings.extend(scan_xxe_file(self.file_path, node, self.xx_rules))
        self.findings.extend(scan_path_traversal_file(self.file_path, node, self.path_traversal_rules))
        self.findings.extend(scan_unvalidated_redirect_file(self.file_path, node, self.unvalidated_redirect_rules))
    
        super().visit(node)


class CodeVulnerabilityVisitor(ast.NodeVisitor):
    def __init__(self, filepath, rules):
        self.findings = []
        self.filepath = filepath
        self.rules_map = {rule['pattern']: rule for rule in rules}
        self.aliases = {}  

    def visit_Import(self, node):
        for alias in node.names:
            self.aliases[alias.asname or alias.name] = alias.name
        self.generic_visit(node)

    def visit_ImportFrom(self, node):
        module = node.module
        for alias in node.names:
            full_name = f"{module}.{alias.name}" if module else alias.name
            self.aliases[alias.asname or alias.name] = full_name
        self.generic_visit(node)

    def visit_Call(self, node):
        full_name = None

        if isinstance(node.func, ast.Name):
            if node.func.id in self.aliases:
                full_name = self.aliases[node.func.id]
            else:
                full_name = node.func.id  

        elif isinstance(node.func, ast.Attribute):
            if isinstance(node.func.value, ast.Name):
                base_name = node.func.value.id
                if base_name in self.aliases:
                    full_name = f"{self.aliases[base_name]}.{node.func.attr}"
                else:
                    full_name = f"{base_name}.{node.func.attr}"
            else:
                full_name = node.func.attr

        if full_name and full_name in self.rules_map:
            rule = self.rules_map[full_name]
            self.findings.append({
                "type": "SAST-WeakCrypto",
                "rule_id": rule["id"],
                "description": rule["description"],
                "file": self.filepath,
                "line": node.lineno,
                "severity": rule["severity"]
            })

        self.generic_visit(node)

class DeserializationAnalyzer(ast.NodeVisitor):
    """
    Finds calls to insecure deserialization functions by tracking imports and aliases.
    """
    def __init__(self, file_path):
        self.vulnerabilities = []
        self.file_path = file_path
        self.aliases = {}
        self.dangerous_deserializers = {
            'pickle': ['load', 'loads'],
            '_pickle': ['load', 'loads'], 
            'shelve': ['open'],
            'yaml': ['load'] 
        }

    def visit_Import(self, node):
        for alias in node.names:
            self.aliases[alias.asname or alias.name] = alias.name
        self.generic_visit(node)

    def visit_ImportFrom(self, node):
        module = node.module
        for alias in node.names:
            full_name = f"{module}.{alias.name}" if module else alias.name
            self.aliases[alias.asname or alias.name] = full_name
        self.generic_visit(node)

    def visit_Call(self, node):
        full_name_of_call = None
        func = node.func

        if isinstance(func, ast.Name):
            full_name_of_call = self.aliases.get(func.id, func.id)
        elif isinstance(func, ast.Attribute) and isinstance(func.value, ast.Name):
            base_name = func.value.id
            attribute_name = func.attr
            resolved_base = self.aliases.get(base_name, base_name)
            full_name_of_call = f"{resolved_base}.{attribute_name}"

        if full_name_of_call:
            parts = full_name_of_call.split('.')
            if len(parts) == 2:
                module, function = parts
                if module in self.dangerous_deserializers and function in self.dangerous_deserializers[module]:
                    self.add_vulnerability(node, full_name_of_call)
        
        self.generic_visit(node)

    def add_vulnerability(self, node, call_name):
        """Helper function to create and add a vulnerability finding."""
        detail = f"Call to insecure deserialization function '{call_name}' detected. Un-trusted data can lead to RCE."
        vuln = {
            "type": "Insecure Deserialization",
            "file": self.file_path,
            "line": node.lineno,
            "detail": detail
        }
        if not any(v['line'] == vuln['line'] and v['type'] == vuln['type'] for v in self.vulnerabilities):
            self.vulnerabilities.append(vuln)

def scan_deserialization_file(filepath):
    all_findings = []
    try:
        with open(filepath, 'r', encoding='utf-8') as f:
            content = f.read()
            tree = ast.parse(content, filename=filepath)
            analyzer = DeserializationAnalyzer(filepath)
            analyzer.visit(tree)
            all_findings.extend(analyzer.vulnerabilities)
    except Exception as e:
        print(f"Could not parse or read file {filepath}: {e}")
    return all_findings

class XXEVisitor(ast.NodeVisitor):
    def __init__(self, filepath, insecure_rules, safelist):
        self.findings = []
        self.filepath = filepath
        self.safelist = safelist
        self.imports = {}

        # --- NEW: Pre-sort and pre-compile rules for efficiency ---
        self.exact_rules = {}
        self.startswith_rules = {}
        self.regex_rules = {}

        for rule in insecure_rules:
            pattern = rule['pattern']
            match_type = rule.get('match_type', 'exact')

            if match_type == 'exact':
                self.exact_rules[pattern] = rule
            elif match_type == 'startswith':
                self.startswith_rules[pattern] = rule
            elif match_type == 'regex':
                # Pre-compile the regex for speed
                self.regex_rules[re.compile(pattern)] = rule

    # ... (visit_Import, visit_ImportFrom, and _get_fqn_from_call helpers remain the same) ...
    def visit_Import(self, node):
        for alias in node.names: self.imports[alias.asname or alias.name] = alias.name
        self.generic_visit(node)
    def visit_ImportFrom(self, node):
        module = node.module
        for alias in node.names:
            full_name = f"{module}.{alias.name}" if module else alias.name
            self.imports[alias.asname or alias.name] = full_name
        self.generic_visit(node)

    def visit_Call(self, node):
        fqn = self._get_fqn_from_call(node)
        if not fqn:
            self.generic_visit(node)
            return

        if any(fqn.startswith(safe_module) for safe_module in self.safelist):
            self.generic_visit(node)
            return

        # --- NEW: Check against all three match types ---
        rule_to_report = None
        
        # 1. Check exact matches (fastest)
        if fqn in self.exact_rules:
            rule_to_report = self.exact_rules[fqn]
        
        # 2. Check startswith matches
        if not rule_to_report:
            for pattern, rule in self.startswith_rules.items():
                if fqn.startswith(pattern):
                    rule_to_report = rule
                    break
        
        # 3. Check regex matches (most flexible)
        if not rule_to_report:
            for pattern_obj, rule in self.regex_rules.items():
                if pattern_obj.search(fqn):
                    rule_to_report = rule
                    break

        if rule_to_report:
            self.findings.append({
                "type": "SAST-XXE", "rule_id": rule_to_report["id"], "description": rule_to_report["description"],
                "file": self.filepath, "line": node.lineno, "severity": rule_to_report["severity"]
            })
        
        self.generic_visit(node)
    
    def _resolve_attribute_chain(self, node):
        if isinstance(node, ast.Attribute):
            return self._resolve_attribute_chain(node.value) + [node.attr]
        elif isinstance(node, ast.Name):
            return [node.id]
        else:
            return []

def scan(filepath, tree, rules):
    """Public scan function. Expects rules to be a dict with keys 'insecure' and 'safe'."""
    insecure_rules = rules.get('insecure', [])
    safelist = rules.get('safe', [])
    visitor = XXEVisitor(filepath, insecure_rules, safelist)
    visitor.visit(tree)
    return visitor.findings

def scan_xxe_file(filepath, tree, rules):
    insecure_rules = rules.get('insecure', [])
    safelist = rules.get('safe', [])
    visitor = XXEVisitor(filepath, insecure_rules, safelist)
    visitor.visit(tree)
    return visitor.findings

class PathTraversalVisitor(ast.NodeVisitor):
    def __init__(self, filepath, rules):
        self.findings = []
        self.filepath = filepath
        self.global_taints = set()
        self.taint_rules = rules
        self.imports = {}
        self.tainted_variables = set()
    def visit_Import(self, node):
        for alias in node.names: self.imports[alias.asname or alias.name] = alias.name
        self.generic_visit(node)
    def visit_ImportFrom(self, node):
        module = node.module
        for alias in node.names:
            full_name = f"{module}.{alias.name}" if module else alias.name
            self.imports[alias.asname or alias.name] = full_name
        self.generic_visit(node)
    def visit_FunctionDef(self, node):
        # Track local taints for this function
        local_taints = set()

        # Analyze assignments in the function
        for sub_node in ast.walk(node):
            if isinstance(sub_node, ast.Assign):
                # RHS is a variable: inherit global taint
                if isinstance(sub_node.value, ast.Name):
                    if sub_node.value.id in self.global_taints:
                        for target in sub_node.targets:
                            if isinstance(target, ast.Name):
                                local_taints.add(target.id)
                else:
                    # RHS is an expression: check if it calls a source
                    if isinstance(sub_node.value, ast.Call):
                        call_fqn = self._get_fqn_from_call(sub_node.value)
                        if call_fqn in self.taint_rules.get('sources', []):
                            for target in sub_node.targets:
                                if isinstance(target, ast.Name):
                                    local_taints.add(target.id)

        # Merge local taints into the global set
        self.global_taints.update(local_taints)

        # Continue traversing the function
        self.generic_visit(node)

    def visit_Assign(self, node):
        if isinstance(node.value, ast.Call):
            call_fqn = self._get_fqn_from_call(node.value)
            if call_fqn in self.taint_rules.get('sources', []):
                for target in node.targets:
                    if isinstance(target, ast.Name): self.tainted_variables.add(target.id)
        self.generic_visit(node)
    def visit_Call(self, node):
        call_fqn = self._get_fqn_from_call(node)
        if call_fqn in self.taint_rules.get('sinks', []):
            for arg in node.args:
                if self._is_arg_tainted(arg):
                    rule = self.taint_rules
                    self.findings.append({
                        "type": "SAST-PathTraversal", "rule_id": rule.get("id", "path-traversal"),
                        "description": f"{rule.get('description', '')} A tainted variable was used in sink '{call_fqn}'.",
                        "file": self.filepath, "line": node.lineno, "severity": rule.get("severity", "High")
                    })
                    break
        self.generic_visit(node)

    def _is_arg_tainted(self, arg_node):
        # Base case: A simple variable name
        if isinstance(arg_node, ast.Name):
            return arg_node.id in self.tainted_variables
        # Recursive step: An operation like "path/" + filename
        elif isinstance(arg_node, ast.BinOp):
            return self._is_arg_tainted(arg_node.left) or self._is_arg_tainted(arg_node.right)
        # Recursive step: A function call like os.path.join(path, filename)
        elif isinstance(arg_node, ast.Call):
            return any(self._is_arg_tainted(arg) for arg in arg_node.args)
        # --- NEW: Handle lists and tuples ---
        elif isinstance(arg_node, (ast.List, ast.Tuple)):
            return any(self._is_arg_tainted(elt) for elt in arg_node.elts)
        # --- NEW: Handle dictionary subscripts like data['key'] ---
        elif isinstance(arg_node, ast.Subscript):
            # Check if either the object or the key is tainted
            return self._is_arg_tainted(arg_node.value) or self._is_arg_tainted(arg_node.slice)
        # In Python 3.9+, ast.Index is removed, the slice is the value itself.
        # For older versions, you might need to access arg_node.slice.value
        elif isinstance(arg_node, ast.Index):
             return self._is_arg_tainted(arg_node.value)
        return False

    def _get_fqn_from_call(self, node):
        if isinstance(node.func, ast.Attribute):
            chain = self._resolve_attribute_chain(node.func)
            if not chain: return None
            base_object = chain[0]
        # Resolve aliases recursively
            while base_object in self.imports:
                base_object = self.imports[base_object].split('.')[0]
            return f"{base_object}.{'.'.join(chain[1:])}"
        elif isinstance(node.func, ast.Name):
            return self.imports.get(node.func.id, node.func.id)
        return None

    def _resolve_attribute_chain(self, node):
        if isinstance(node, ast.Attribute):
            return self._resolve_attribute_chain(node.value) + [node.attr]
        elif isinstance(node, ast.Name):
            return [node.id]
        else:
            return []


def scan_path_traversal_file(filepath, tree, rules):
    visitor = PathTraversalVisitor(filepath, rules)
    visitor.visit(tree)
    return visitor.findings

class UnvalidatedRedirectVisitor(ast.NodeVisitor):
    """
    Performs taint analysis to find Unvalidated Redirect vulnerabilities.
    """
    def __init__(self, filepath, rules):
        self.findings = []
        self.filepath = filepath
        self.taint_rules = rules # Expects {'sources': [...], 'sinks': [...]}
        self.global_taints = set()
        self.imports = {}
        self.tainted_variables = set()

    # --- Import visitors for alias tracking ---
    def visit_Import(self, node):
        for alias in node.names: self.imports[alias.asname or alias.name] = alias.name
        self.generic_visit(node)

    def visit_ImportFrom(self, node):
        module = node.module
        for alias in node.names:
            full_name = f"{module}.{alias.name}" if module else alias.name
            self.imports[alias.asname or alias.name] = full_name
        self.generic_visit(node)

    def visit_FunctionDef(self, node):
        # Track local taints for this function
        local_taints = set()

        # Analyze assignments in the function
        for sub_node in ast.walk(node):
            if isinstance(sub_node, ast.Assign):
                # RHS is a variable: inherit global taint
                if isinstance(sub_node.value, ast.Name):
                    if sub_node.value.id in self.global_taints:
                        for target in sub_node.targets:
                            if isinstance(target, ast.Name):
                                local_taints.add(target.id)
                else:
                    # RHS is an expression: check if it calls a source
                    if isinstance(sub_node.value, ast.Call):
                        call_fqn = self._get_fqn_from_call(sub_node.value)
                        if call_fqn in self.taint_rules.get('sources', []):
                            for target in sub_node.targets:
                                if isinstance(target, ast.Name):
                                    local_taints.add(target.id)

        # Merge local taints into the global set
        self.global_taints.update(local_taints)

        # Continue traversing the function
        self.generic_visit(node)


    def visit_Assign(self, node):
        """Checks if a variable is being tainted by a dangerous source."""
        if isinstance(node.value, ast.Call):
            call_fqn = self._get_fqn_from_call(node.value)
            if call_fqn in self.taint_rules.get('sources', []):
                for target in node.targets:
                    if isinstance(target, ast.Name):
                        self.tainted_variables.add(target.id)
        self.generic_visit(node)

    def visit_Call(self, node):
        """Checks if a redirect sink is called with a tainted variable."""
        call_fqn = self._get_fqn_from_call(node)
        if call_fqn in self.taint_rules.get('sinks', []):
            for arg in node.args:
                if self._is_arg_tainted(arg):
                    rule = self.taint_rules
                    self.findings.append({
                        "type": "SAST-UnvalidatedRedirect",
                        "rule_id": rule.get("id", "unvalidated-redirect"),
                        "description": f"{rule.get('description', '')} A tainted variable was used in sink '{call_fqn}'.",
                        "file": self.filepath,
                        "line": node.lineno,
                        "severity": rule.get("severity", "Medium")
                    })
                    break
        self.generic_visit(node)

    def _is_arg_tainted(self, arg_node):
        """Recursively checks if any variable in an expression is tainted."""
        if isinstance(arg_node, ast.Name): return arg_node.id in self.tainted_variables
        elif isinstance(arg_node, ast.BinOp): return self._is_arg_tainted(arg_node.left) or self._is_arg_tainted(arg_node.right)
        elif isinstance(arg_node, ast.Call): return any(self._is_arg_tainted(arg) for arg in arg_node.args)
        # ... (add other expression types like Subscript, List, etc. as needed) ...
        return False

    def _get_fqn_from_call(self, node):
        """Helper to resolve the fully qualified name of a Call node."""
        if isinstance(node.func, ast.Attribute):
            chain = self._resolve_attribute_chain(node.func)
            if not chain: return None
            base_object = chain[0]
            module_name = self.imports.get(base_object, base_object)
            return f"{module_name}.{'.'.join(chain[1:])}"
        elif isinstance(node.func, ast.Name):
            func_name = node.func.id
            return self.imports.get(func_name, func_name)
        return None
    
    def _resolve_attribute_chain(self, node):
        if isinstance(node, ast.Attribute): return self._resolve_attribute_chain(node.value) + [node.attr]
        elif isinstance(node, ast.Name): return [node.id]
        else: return []

def scan_unvalidated_redirect_file(filepath, tree, rules):
    visitor = UnvalidatedRedirectVisitor(filepath, rules)
    visitor.visit(tree)
    return visitor.findings

class ASTAnalyzer(ast.NodeVisitor):
   #Creates a Tree of the code to be analyzed.
    def __init__(self, file_path, rules):
        self.vulnerabilities = []
        self.file_path = file_path
        self.rules = rules 

    def visit_Call(self, node):
        
        for rule in self.rules:
            detection_logic = rule.get('detection', {})
            
            if detection_logic.get('node_type') == 'Call':
                if self.node_matches_rule(node, detection_logic):
                    vuln = {
                        "type": rule.get('name', 'Unnamed Rule'),
                        "file": self.file_path,
                        "line": node.lineno,
                        "code": ast.unparse(node).strip()
                    }
                    self.vulnerabilities.append(vuln)

        
        self.generic_visit(node)

    def node_matches_rule(self, node, detection_logic):
        
        if detection_logic.get('function_is_attribute'):
            if not isinstance(node.func, ast.Attribute):
                return False

            props = detection_logic.get('function_call_properties', {})
            func_value = node.func.value


            if 'object_name' in props:
                if not (isinstance(func_value, ast.Name) and func_value.id == props['object_name']):
                    return False
            

            if 'function_name' in props:
                if node.func.attr != props['function_name']:
                    return False

            if 'keyword_argument' in props:
                kw_props = props['keyword_argument']
                found_kw = False
                for kw in node.keywords:
                    if (kw.arg == kw_props['name'] and 
                        isinstance(kw.value, ast.Constant) and 
                        kw.value.value == kw_props['value']):
                        found_kw = True
                        break
                if not found_kw:
                    return False
        

        if 'argument_properties' in detection_logic:
            for arg_prop in detection_logic['argument_properties']:
                arg_pos = arg_prop.get('position', 0)
                if len(node.args) > arg_pos:
                    arg_node = node.args[arg_pos]
                    if arg_prop.get('is_formatted_string'):
                        if not (isinstance(arg_node, ast.JoinedStr) or isinstance(arg_node, ast.BinOp)):
                            return False
                else:
                    return False


        return True

def load_rules(filepath=None):
    if not filepath:
        filepath = os.path.join(os.getcwd(), "rules.yaml")
    if not os.path.exists(filepath):
        print(f"[!] Error: Rule file '{filepath}' not found.")
        sys.exit(1)
    with open(filepath, 'r') as f:
        return yaml.safe_load(f)

def scan_directory(directory_path, rules):
    
    all_vulnerabilities = []
    print(f"[*] Starting scan in directory: {directory_path}\n")

    for root, _, files in os.walk(directory_path):
        for file in files:
            if file.endswith(".py"):
                file_path = os.path.join(root, file)
                print(f"  -> Analyzing: {file_path}")
                try:
                    with open(file_path, "r", encoding='utf-8') as source_file:
                        source_code = source_file.read()
                        tree = ast.parse(source_code, filename=file_path)
                        combined = CombinedAnalyzer(file_path, rules)
                        combined.visit(tree)
                        all_vulnerabilities.extend(combined.findings)
                except Exception as e:
                    print(f"     [!] Could not parse or analyze {file_path}. Skipping. Error: {e}")

    return all_vulnerabilities


# --- Taint Analysis Scanner for XSS ---
class XSSAnalyzer(ast.NodeVisitor):
    """
    Performs taint analysis for XSS vulnerabilities.
    It now dynamically loads sources and sinks from a rules dictionary.
    """
    def __init__(self, file_path, rules):
        self.vulnerabilities = []
        self.file_path = file_path
        self.global_taints = set()
        # Dynamically load sources and sinks from the provided rules
        self.sources = rules.get('sources', [])
        self.sinks = rules.get('sinks', [])

    def visit_FunctionDef(self, node):
    # Track local taints for this function
        local_taints = set()
        
        # Analyze assignments in function to find tainted variables
        for sub_node in ast.walk(node):
            if isinstance(sub_node, ast.Assign):
                if isinstance(sub_node.value, ast.Name):
                    # If the RHS is already globally tainted, mark LHS as tainted
                    if sub_node.value.id in self.global_taints:
                        for target in sub_node.targets:
                            if isinstance(target, ast.Name):
                                local_taints.add(target.id)
                else:
                    # Check if RHS contains sources
                    rhs_str = ast.unparse(sub_node.value)
                    if any(src in rhs_str for src in self.sources):
                        for target in sub_node.targets:
                            if isinstance(target, ast.Name):
                                local_taints.add(target.id)
        
        # Merge local taints into global taints
        self.global_taints.update(local_taints)
        self.generic_visit(node)

# --- Rule-Based Scanner for Patterns ---
class RuleBasedScanner(ast.NodeVisitor):
    def __init__(self, file_path, rules):
        self.vulnerabilities = []
        self.file_path = file_path
        self.rules_map = {r['pattern']: r for r in rules}
        self.imports = {}  # Track aliases

    def visit_Import(self, node):
        for alias in node.names:
            self.imports[alias.asname or alias.name] = alias.name
        self.generic_visit(node)

    def visit_ImportFrom(self, node):
        module = node.module
        for alias in node.names:
            full_name = f"{module}.{alias.name}" if module else alias.name
            self.imports[alias.asname or alias.name] = full_name
        self.generic_visit(node)

    def visit_Call(self, node):
        fqn = self._get_fqn_from_call(node)
        if fqn and fqn in self.rules_map:
            rule = self.rules_map[fqn]
            self.vulnerabilities.append({
                "type": rule.get('id', 'Pattern Match'),
                "file": self.file_path,
                "line": node.lineno,
                "code": ast.unparse(node).strip(),
                "severity": rule.get('severity', 'N/A'),
                "detail": rule.get('description', '')
            })
        self.generic_visit(node)

    def _get_fqn_from_call(self, node):
        # Resolves fully qualified names like "hashlib.md5" even with aliases
        if isinstance(node.func, ast.Name):
            return self.imports.get(node.func.id, node.func.id)
        elif isinstance(node.func, ast.Attribute):
            chain = []
            curr = node.func
            while isinstance(curr, ast.Attribute):
                chain.insert(0, curr.attr)
                curr = curr.value
            if isinstance(curr, ast.Name):
                base = self.imports.get(curr.id, curr.id)
                chain.insert(0, base)
                return ".".join(chain)
        return None
def deduplicate_findings(findings):
    seen = set()
    unique = []
    for f in findings:
        key = (f["file"], f.get("line"), f.get("type"), f.get("rule_id"))
        if key not in seen:
            seen.add(key)
            unique.append(f)
    return unique

def scan_file(filepath, all_rules):
    all_findings = []
    try:
        with open(filepath, 'r', encoding='utf-8') as f:
            tree = ast.parse(f.read(), filename=filepath)
            combined = CombinedAnalyzer(filepath, all_rules)
            combined.visit(tree)

        analyzers = [
            ("XSSAnalyzer", lambda: XSSAnalyzer(filepath, all_rules.get('xss_rules', {}))),
            ("RuleBasedScanner", lambda: RuleBasedScanner(
                filepath,
                all_rules.get('weak_crypto_rules', []) + all_rules.get('insecure_deserialization_rules', [])
            )),
            ("DeserializationAnalyzer", lambda: scan_deserialization_file(filepath)),
            ("XXEVisitor", lambda: scan_xxe_file(filepath, tree, all_rules)),
            ("PathTraversalVisitor", lambda: scan_path_traversal_file(filepath, tree, all_rules)),
            ("UnvalidatedRedirectVisitor", lambda: scan_unvalidated_redirect_file(filepath, tree, all_rules)),
        ]

        for name, factory in analyzers:
            try:
                result = factory()
                # If it's a visitor object with vulnerabilities attribute:
                if hasattr(result, 'vulnerabilities'):
                    all_findings.extend(result.vulnerabilities)
                else:  # If it's already a list of findings
                    all_findings.extend(result)
            except Exception as e:
                print(f"[!] Analyzer {name} failed on {filepath}: {e}")

    except Exception as e:
        print(f"[!] Failed to read or parse file {filepath}: {e}")

    all_findings = deduplicate_findings(all_findings)
    return all_findings


