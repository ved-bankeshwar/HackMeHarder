# /SAST/vulnerability_scanner.py
import ast
import os
import yaml
import sys

# ========================= Framework-Specific Analyzer ========================= #

class FlaskRouteAnalyzer(ast.NodeVisitor):
    """
    A specialized visitor that only finds Flask routes and maps them to the functions they decorate.
    This provides the web context needed for other scanners.
    """
    def __init__(self):
        self.route_map = {}  # Maps function names to {'url', 'methods'}

    def visit_FunctionDef(self, node):
        for decorator in node.decorator_list:
            # Check if decorator is a call like @app.route(...)
            if (isinstance(decorator, ast.Call) and isinstance(decorator.func, ast.Attribute) and
                    decorator.func.attr == 'route'):
                
                url = decorator.args[0].s if decorator.args and isinstance(decorator.args[0], ast.Constant) else '/'
                methods = ['GET']  # Default Flask method
                for kw in decorator.keywords:
                    if kw.arg == 'methods' and isinstance(kw.value, (ast.List, ast.Tuple)):
                        methods = [m.s for m in kw.value.elts if isinstance(m, ast.Constant)]
                
                self.route_map[node.name] = {'url': url, 'methods': methods}
        self.generic_visit(node)

# ========================= Taint Analysis Base Visitor ========================= #

class TaintVisitor(ast.NodeVisitor):
    """
    A base class for taint analysis visitors (SQLi, Command Injection, etc.)
    It handles common tasks like tracking imports, aliases, and tainted variables,
    and linking findings back to Flask routes.
    """
    def __init__(self, filepath, rules, route_map, vuln_type, vuln_name):
        self.filepath = filepath
        self.rules = rules or {}
        self.route_map = route_map or {}
        self.vuln_type = vuln_type
        self.vuln_name = vuln_name

        self.findings = []
        self.imports = {}
        self.tainted_variables = {}  # Maps func_name -> set of (var_name, param_name)

    def visit_FunctionDef(self, node):
        # Only perform taint analysis inside functions that are known web routes
        if node.name in self.route_map:
            self.tainted_variables[node.name] = set()
            self._propagate_taint(node)
        self.generic_visit(node)

    def _propagate_taint(self, func_node):
        # Step 1: Find all sources and taint the variables they are assigned to
        for node in ast.walk(func_node):
            if isinstance(node, ast.Assign):
                source_details = self._get_source_details(node.value)
                if source_details:
                    param_name = source_details['param']
                    for target in node.targets:
                        if isinstance(target, ast.Name):
                            self.tainted_variables[func_node.name].add((target.id, param_name))

        # Step 2: Find all sinks and check if they are called with tainted arguments
        for node in ast.walk(func_node):
            if isinstance(node, ast.Call):
                call_fqn = self._get_fqn_from_call(node)
                if call_fqn in self.rules.get('sinks', []):
                    # Check if any argument to the sink is tainted
                    tainted_args = self._find_tainted_args(node, self.tainted_variables[func_node.name])
                    if tainted_args:
                        param_name = tainted_args[0][1]  # Get param from the first tainted var
                        route_info = self.route_map.get(func_node.name)
                        
                        for method in route_info['methods']:
                            self._add_finding(
                                node, call_fqn, param_name, route_info['url'], method
                            )
                        # Break after finding one tainted arg to avoid duplicate reports for the same sink call
                        break

    def _get_source_details(self, node):
        if (isinstance(node, ast.Call) and isinstance(node.func, ast.Attribute) and
                isinstance(node.func.value, ast.Attribute) and node.func.value.attr in ['args', 'form']):
            
            source_pattern = f"request.{node.func.value.attr}.get"
            if source_pattern in self.rules.get('sources', []):
                if node.args and isinstance(node.args[0], ast.Constant):
                    return {"source": source_pattern, "param": node.args[0].s}
        return None

    def _find_tainted_args(self, call_node, tainted_in_scope):
        found = []
        tainted_names = {var[0] for var in tainted_in_scope}
        for arg in ast.walk(call_node):
            if isinstance(arg, ast.Name) and arg.id in tainted_names:
                original_param = next((var for var in tainted_in_scope if var[0] == arg.id), None)
                if original_param:
                    found.append(original_param)
        return found
        
    def _add_finding(self, node, sink, param, url, method):
        finding = {
            "type": self.vuln_name,
            "file": self.filepath,
            "line": node.lineno,
            "sast_details": {
                "description": f"Tainted data from parameter '{param}' flows into the dangerous sink '{sink}'."
            },
            # --- Data for DAST Correlation ---
            "url": url,
            "method": method,
            "param": param,
        }
        # Avoid adding exact duplicates
        if finding not in self.findings:
            self.findings.append(finding)

    def visit_Import(self, node):
        for alias in node.names:
            self.imports[alias.asname or alias.name] = alias.name
        self.generic_visit(node)

    def visit_ImportFrom(self, node):
        module = node.module
        for alias in node.names:
            full_name = f"{module}.{alias.name}" if module else alias.name
            self.imports[alias.asname or alias.name] = full_name
        self.generic_visit(node)

    def _get_fqn_from_call(self, node):
        if isinstance(node.func, ast.Name):
            return self.imports.get(node.func.id, node.func.id)
        elif isinstance(node.func, ast.Attribute):
            chain = []
            curr = node.func
            while isinstance(curr, ast.Attribute):
                chain.insert(0, curr.attr)
                curr = curr.value
            if isinstance(curr, ast.Name):
                base = self.imports.get(curr.id, curr.id)
                chain.insert(0, base)
                return ".".join(chain)
        # Handle cases like f"string".format() which don't have a simple FQN
        elif isinstance(node.func, ast.Attribute) and isinstance(node.func.value, ast.Constant):
             return f"str.{node.func.attr}"
        return ast.unparse(node.func) # Fallback for complex cases

# ========================= Specific Taint Visitors ========================= #

class SQLInjectionVisitor(TaintVisitor):
    def __init__(self, filepath, rules, route_map):
        super().__init__(filepath, rules, route_map, "SAST-SQLInjection", "SQL Injection")

class CommandInjectionVisitor(TaintVisitor):
    def __init__(self, filepath, rules, route_map):
        super().__init__(filepath, rules, route_map, "SAST-CommandInjection", "Command Injection")

class PathTraversalVisitor(TaintVisitor):
    def __init__(self, filepath, rules, route_map):
        super().__init__(filepath, rules, route_map, "SAST-PathTraversal", "Path Traversal")
        
class XSSVisitor(TaintVisitor):
    def __init__(self, filepath, rules, route_map):
        super().__init__(filepath, rules, route_map, "SAST-XSS", "Cross-Site Scripting")

# ========================= Standalone Scanners ========================= #
# These scanners do not depend on taint analysis from web routes

class DeserializationAnalyzer(ast.NodeVisitor):
    # ... (code for this class remains the same as your teammate's, no changes needed)
    def __init__(self, file_path):
        self.vulnerabilities = []
        self.file_path = file_path
        self.aliases = {}
        self.dangerous_deserializers = {
            'pickle': ['load', 'loads'], '_pickle': ['load', 'loads'],
            'shelve': ['open'], 'yaml': ['load']
        }
    def visit_Import(self, node):
        for alias in node.names: self.aliases[alias.asname or alias.name] = alias.name
        self.generic_visit(node)
    def visit_ImportFrom(self, node):
        module = node.module
        for alias in node.names:
            full_name = f"{module}.{alias.name}" if module else alias.name
            self.aliases[alias.asname or alias.name] = full_name
        self.generic_visit(node)
    def visit_Call(self, node):
        full_name_of_call = None
        func = node.func
        if isinstance(func, ast.Name):
            full_name_of_call = self.aliases.get(func.id, func.id)
        elif isinstance(func, ast.Attribute) and isinstance(func.value, ast.Name):
            base_name = func.value.id
            full_name_of_call = f"{self.aliases.get(base_name, base_name)}.{func.attr}"
        if full_name_of_call:
            parts = full_name_of_call.split('.')
            if len(parts) == 2:
                module, function = parts
                if module in self.dangerous_deserializers and function in self.dangerous_deserializers[module]:
                    self.add_vulnerability(node, full_name_of_call)
        self.generic_visit(node)
    def add_vulnerability(self, node, call_name):
        detail = f"Call to insecure deserialization function '{call_name}' detected."
        vuln = {"type": "Insecure Deserialization", "file": self.file_path, "line": node.lineno, "detail": detail}
        if not any(v['line'] == vuln['line'] and v['type'] == vuln['type'] for v in self.vulnerabilities):
            self.vulnerabilities.append(vuln)