# SAST/vulnerability_scanner.py

import ast
import yaml

class VulnerabilityScanner(ast.NodeVisitor):
    def __init__(self, rules_file):
        with open(rules_file, 'r') as f:
            self.rules = yaml.safe_load(f)
        
        self.vulnerabilities = []
        self.tainted_variables = set()
        self.current_file = ""

    def scan_file(self, filepath):
        self.current_file = filepath
        self.tainted_variables.clear() # Reset for each file
        with open(filepath, 'r', encoding='utf-8') as file:
            tree = ast.parse(file.read(), filename=filepath)
            self.visit(tree)
        return self.vulnerabilities

    def visit_Assign(self, node):
        # --- FIX: Taint Propagation ---
        # Check if the value being assigned comes from a source
        if isinstance(node.value, ast.Call):
            # Check for simple function calls, e.g., request.args.get()
            if isinstance(node.value.func, ast.Attribute) and \
               node.value.func.attr in self.rules['taint_analysis']['sources']:
                
                # This logic assumes simple assignments like `var = source()`
                for target in node.targets:
                    if isinstance(target, ast.Name):
                        self.tainted_variables.add(target.id)
                        # print(f"  [Taint] Variable '{target.id}' tainted at line {node.lineno}")

        # Continue traversing the tree
        self.generic_visit(node)

    def visit_Call(self, node):
        function_name = ""
        if isinstance(node.func, ast.Attribute):
            function_name = node.func.attr
        elif isinstance(node.func, ast.Name):
            function_name = node.func.id

        # Check if this function call is a "sink"
        if function_name in self.rules['taint_analysis']['sinks']:
            is_vulnerable = False
            # Check if any argument passed to the sink is tainted
            for arg in node.args:
                # Direct use of a source function in a sink
                if isinstance(arg, ast.Call) and isinstance(arg.func, ast.Attribute) and \
                   arg.func.attr in self.rules['taint_analysis']['sources']:
                    is_vulnerable = True
                    break
                
                # --- FIX: Check for Tainted Variables ---
                # Use of a variable that was previously tainted
                if isinstance(arg, ast.Name) and arg.id in self.tainted_variables:
                    is_vulnerable = True
                    break

            if is_vulnerable:
                vuln_type = self.rules['taint_analysis']['sinks'][function_name]['type']
                self.vulnerabilities.append({
                    "file": self.current_file,
                    "line": node.lineno,
                    "type": vuln_type,
                    "sink": function_name,
                    "message": f"Potential {vuln_type} vulnerability. Tainted data reached sink '{function_name}'."
                })

        self.generic_visit(node)