import ast
import json
import os
import yaml
import re
import sys
import argparse

# Helper to unparse AST nodes safely, for logging/reporting
def safe_unparse(node):
    try:
        return ast.unparse(node)
    except Exception:
        return "Unparseable Node"

# --- Taint Analysis Base Visitor ---
class TaintAnalysisVisitor(ast.NodeVisitor):
    """
    A base class for taint analysis visitors (XSS, Path Traversal, etc.)
    that standardizes how taints are tracked and reported.
    """
    def __init__(self, filepath, rules, finding_type, rule_id_prefix):
        self.findings = []
        self.filepath = filepath
        self.rules = rules
        self.finding_type = finding_type
        self.rule_id_prefix = rule_id_prefix
        
        self.sources = rules.get('sources', [])
        self.sinks = rules.get('sinks', [])
        
        self.imports = {}
        self.tainted_variables = set()
        self.taint_sources = {}  # Tracks the origin of a taint (e.g., "request.args.get('name')")

    def visit_Import(self, node):
        for alias in node.names:
            self.imports[alias.asname or alias.name] = alias.name
        self.generic_visit(node)

    def visit_ImportFrom(self, node):
        module = node.module
        for alias in node.names:
            full_name = f"{module}.{alias.name}" if module else alias.name
            self.imports[alias.asname or alias.name] = full_name
        self.generic_visit(node)

    def visit_Assign(self, node):
        """Checks if a variable is being tainted by a dangerous source."""
        if isinstance(node.value, ast.Call):
            call_fqn = self._get_fqn_from_call(node.value)
            if any(call_fqn.endswith(src) for src in self.sources):
                for target in node.targets:
                    if isinstance(target, ast.Name):
                        self.tainted_variables.add(target.id)
                        # Store the exact source expression that tainted the variable
                        self.taint_sources[target.id] = safe_unparse(node.value)
        self.generic_visit(node)

    def visit_Call(self, node):
        """Checks if a dangerous sink is called with a tainted variable."""
        call_fqn = self._get_fqn_from_call(node)
        if any(call_fqn.endswith(sink) for sink in self.sinks):
            for arg in node.args:
                tainted_var = self._get_tainted_var_from_arg(arg)
                if tainted_var:
                    self.findings.append({
                        "type": self.finding_type,
                        "rule_id": self.rules.get("id", self.rule_id_prefix),
                        "description": self.rules.get("description"),
                        "detail": f"Tainted variable '{tainted_var}' from source '{self.taint_sources.get(tainted_var, 'unknown')}' used in sink '{call_fqn}'.",
                        "file": self.filepath,
                        "line": node.lineno,
                        "severity": self.rules.get("severity", "High")
                    })
                    break  # Found a tainted arg, no need to check others for this call
        self.generic_visit(node)

    def _get_tainted_var_from_arg(self, arg_node):
        """Recursively find the name of a tainted variable in an expression."""
        if isinstance(arg_node, ast.Name) and arg_node.id in self.tainted_variables:
            return arg_node.id
        elif isinstance(arg_node, (ast.BinOp, ast.JoinedStr)):
            # Check left and right sides of binary operations or parts of f-strings
            if isinstance(arg_node, ast.BinOp):
                operands = [arg_node.left, arg_node.right]
            else: # JoinedStr
                operands = arg_node.values

            for op in operands:
                tainted = self._get_tainted_var_from_arg(op)
                if tainted: return tainted
        elif isinstance(arg_node, ast.Call):
            for arg in arg_node.args:
                tainted = self._get_tainted_var_from_arg(arg)
                if tainted: return tainted
        elif isinstance(arg_node, ast.FormattedValue):
            return self._get_tainted_var_from_arg(arg_node.value)
        return None

    def _get_fqn_from_call(self, node):
        """Helper to resolve the fully qualified name of a Call node."""
        if isinstance(node.func, ast.Attribute):
            chain = self._resolve_attribute_chain(node.func)
            if not chain: return None
            base_object = self.imports.get(chain[0], chain[0])
            return f"{base_object}.{'.'.join(chain[1:])}"
        elif isinstance(node.func, ast.Name):
            return self.imports.get(node.func.id, node.func.id)
        return None

    def _resolve_attribute_chain(self, node):
        if isinstance(node, ast.Attribute):
            return self._resolve_attribute_chain(node.value) + [node.attr]
        elif isinstance(node, ast.Name):
            return [node.id]
        return []

# --- Main Scanner Functions ---

def load_rules(filepath=None):
    if not filepath:
        filepath = os.path.join(os.path.dirname(__file__), '..', "rules.yaml")
    if not os.path.exists(filepath):
        print(f"[!] Error: Rule file '{filepath}' not found.")
        sys.exit(1)
    with open(filepath, 'r') as f:
        return yaml.safe_load(f)

def scan_directory(directory_path, rules):
    all_findings = []
    print(f"[*] Starting SAST scan in directory: {directory_path}")

    for root, _, files in os.walk(directory_path):
        for file in files:
            if file.endswith(".py"):
                file_path = os.path.join(root, file)
                try:
                    with open(file_path, "r", encoding='utf-8') as source_file:
                        source_code = source_file.read()
                        tree = ast.parse(source_code, filename=file_path)
                        
                        # Initialize and run all taint analysis visitors
                        taint_visitors = [
                            TaintAnalysisVisitor(file_path, rules.get('taint_analysis_rules', {}).get('sql_injection', {}), "SQL Injection", "sqli"),
                            TaintAnalysisVisitor(file_path, rules.get('taint_analysis_rules', {}).get('path_traversal', {}), "SAST-PathTraversal", "path-traversal"),
                            TaintAnalysisVisitor(file_path, rules.get('taint_analysis_rules', {}).get('unvalidated_redirect', {}), "SAST-UnvalidatedRedirect", "unvalidated-redirect"),
                            TaintAnalysisVisitor(file_path, rules.get('xss_rules', {}), "Cross-Site Scripting", "xss"),
                        ]

                        for visitor in taint_visitors:
                            visitor.visit(tree)
                            all_findings.extend(visitor.findings)

                except Exception as e:
                    print(f"     [!] Could not parse or analyze {file_path}. Skipping. Error: {e}")
    
    # Deduplicate findings
    unique_findings = []
    seen = set()
    for finding in all_findings:
        key = (finding['file'], finding['line'], finding['type'])
        if key not in seen:
            unique_findings.append(finding)
            seen.add(key)
            
    return unique_findings
