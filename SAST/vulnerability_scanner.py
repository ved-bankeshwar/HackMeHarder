# /SAST/vulnerability_scanner.py

import ast
print("--- EXECUTING THE NEW, CORRECT SCANNER ---")
class FlaskTaintAnalyzer(ast.NodeVisitor):
    """
    An AST visitor that is purpose-built to find web vulnerabilities for DAST correlation.
    It performs three tasks in a single pass:
    1. Discovers Flask routes (@app.route) and their correct HTTP methods.
    2. Tracks tainted data from user-controlled sources (like request.args).
    3. When a tainted variable is used in a dangerous sink, it records a finding
       with the precise URL, method, and parameter for DAST to use.
    """
    def __init__(self, filepath, rules):
        self.filepath = filepath
        self.rules = rules or {}
        self.findings = []
        self.tainted_variables = {}  # Maps func_name -> set of (var_name, param_name)

    def visit_FunctionDef(self, node):
        # Find the route decorator for this function, if it exists
        route_info = self._get_route_info(node)
        
        # Only analyze functions that are web endpoints
        if route_info:
            self.tainted_variables[node.name] = set()
            self._analyze_function_body(node, route_info)

        self.generic_visit(node)

    def _get_route_info(self, func_node):
        for decorator in func_node.decorator_list:
            if (isinstance(decorator, ast.Call) and isinstance(decorator.func, ast.Attribute) and
                    decorator.func.attr == 'route'):
                
                url = decorator.args[0].s if decorator.args and isinstance(decorator.args[0], ast.Constant) else '/'
                
                # This logic correctly defaults to GET
                methods = ['GET']
                for kw in decorator.keywords:
                    if kw.arg == 'methods' and isinstance(kw.value, (ast.List, ast.Tuple)):
                        methods = [m.s for m in kw.value.elts if isinstance(m, ast.Constant)]
                
                return {'url': url, 'methods': methods}
        return None

    def _analyze_function_body(self, func_node, route_info):
        """Perform taint analysis within the scope of a single function."""
        # Find sources and taint variables
        for node in ast.walk(func_node):
            if isinstance(node, ast.Assign):
                source_details = self._get_source_details(node.value)
                if source_details:
                    param_name = source_details['param']
                    for target in node.targets:
                        if isinstance(target, ast.Name):
                            self.tainted_variables[func_node.name].add((target.id, param_name))

        # Find sinks and check for tainted arguments
        for node in ast.walk(func_node):
            if isinstance(node, ast.Call):
                call_fqn = self._get_fqn_from_call(node)
                
                for vuln_name, rule in self.rules.items():
                    if call_fqn in rule.get('sinks', []):
                        tainted_args = self._find_tainted_args(node, self.tainted_variables[func_node.name])
                        if tainted_args:
                            param_name = tainted_args[0][1]
                            for method in route_info['methods']:
                                self._add_finding(node, call_fqn, param_name, route_info, method, rule)
                            break 

    def _get_source_details(self, node):
        if (isinstance(node, ast.Call) and isinstance(node.func, ast.Attribute) and
                hasattr(node.func, 'value') and isinstance(node.func.value, ast.Attribute) and
                node.func.value.attr in ['args', 'form']):
            
            source_pattern = f"request.{node.func.value.attr}.get"
            
            for rule in self.rules.values():
                if source_pattern in rule.get('sources', []):
                    if node.args and isinstance(node.args[0], ast.Constant):
                        return {"source": source_pattern, "param": node.args[0].s}
        return None
        
    def _find_tainted_args(self, call_node, tainted_in_scope):
        found = []
        tainted_names = {var[0] for var in tainted_in_scope}
        for arg in ast.walk(call_node):
            if isinstance(arg, ast.Name) and arg.id in tainted_names:
                original_param = next((var for var in tainted_in_scope if var[0] == arg.id), None)
                if original_param:
                    found.append(original_param)
        return found

    def _add_finding(self, node, sink, param, route_info, method, rule):
        finding = {
            "type": rule.get("name", "Unknown Vulnerability"),
            "file": self.filepath,
            "line": node.lineno,
            "sast_details": { "description": f"Tainted data from parameter '{param}' flows into the dangerous sink '{sink}'." },
            "url": route_info['url'],
            "method": method,
            "param": param,
        }
        if finding not in self.findings:
            self.findings.append(finding)

    def _get_fqn_from_call(self, node):
        return ast.unparse(node.func)